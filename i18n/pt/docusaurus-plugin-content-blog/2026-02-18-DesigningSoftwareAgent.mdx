---
title: "Projetando Software para um Mundo Onde os Agentes S√£o Primeiros"
description: Arquitetura, reposit√≥rios e pr√°ticas de engenharia devem evoluir para a era GenAI. Aprenda como projetar sistemas amig√°veis para agentes que sobrevivam mudan√ßas de modelos, habilitem contribui√ß√µes aut√¥nomas seguras e tornem humanos e m√°quinas mais eficazes.
slug: designing-software-agent-first-world
authors: [dsanchezcr]
tags: [AI, GitHub Copilot, Agentic AI, Software Engineering, Architecture, DevOps]
enableComments: true
hide_table_of_contents: true
image: https://raw.githubusercontent.com/dsanchezcr/website/refs/heads/main/static/img/blog/2026-02-18-DesigningSoftwareAgent/designing-software-agent-first-world.jpg
date: 2026-02-18T10:00
---

# Projetando Software para um Mundo Onde os Agentes S√£o Primeiros

## Seu Reposit√≥rio √â Agora Sua Interface Mais Importante

O papel do engenheiro de software est√° evoluindo rapidamente, n√£o porque a IA pode gerar c√≥digo, mas porque o desenvolvimento de software em si est√° se tornando um **sistema colaborativo humano-agente**.

Nos √∫ltimos anos, passamos da IA auxiliando com trechos de c√≥digo, para gerar fun√ß√µes inteiras, para propor pull requests, e agora para **agentes que navegam reposit√≥rios, raciocinam sobre arquitetura e executam tarefas de desenvolvimento de m√∫ltiplas etapas de forma aut√¥noma**.

<!--truncate-->

![Projetando Software para um Mundo Onde os Agentes S√£o Primeiros](pathname:///img/blog/2026-02-18-DesigningSoftwareAgent/designing-software-agent-first-world.jpg)

Nos meus posts anteriores, explorei como [as pr√°ticas fundamentais de DevOps preparam o sistema](/blog/agentic-devops-foundations), como [o papel do engenheiro de software est√° evoluindo](/blog/evolution-of-the-software-engineer), e como [humanos e agentes colaboram atrav√©s de IDEs e pull requests](/blog/humans-and-agents-collaboration-patterns). Este post aborda a pr√≥xima pergunta cr√≠tica:

> **Como devemos projetar nossos sistemas de software para que os agentes possam trabalhar neles de forma eficaz, segura e em escala?**

O ritmo de inova√ß√£o em GenAI e LLMs pode parecer avassalador. Novos modelos, capacidades, frameworks e melhores pr√°ticas aparecem constantemente. Muitos desenvolvedores est√£o perguntando: *Quais modelos devo usar? Como estruturo meu repo para que os agentes o entendam? O que significa "melhor pr√°tica" quando as ferramentas evoluem mensalmente?*

A resposta n√£o √© perseguir cada novo modelo ou funcionalidade.

A resposta √© **projetar sistemas de software que sejam amig√°veis para agentes por padr√£o**.

---

## Da Codifica√ß√£o Assistida por IA √† Engenharia Onde os Agentes S√£o Primeiros

O design de software tradicional assumia que humanos escrevem c√≥digo, humanos leem documenta√ß√£o de arquitetura, humanos entendem a inten√ß√£o e humanos coordenam mudan√ßas. Essas suposi√ß√µes n√£o se sustentam mais.

A engenharia ag√™ntica introduz uma nova realidade:

> **Seu software ser√° lido, modificado, testado e analisado tanto por m√°quinas quanto por humanos.**

Isso muda o que "boa engenharia" significa. Um bom design n√£o √© mais apenas leg√≠vel para humanos e mant√≠vel por equipes. Tamb√©m deve ser:

- **Naveg√°vel por agentes**, estrutura clara, conven√ß√µes expl√≠citas, padr√µes descobr√≠veis
- **Verific√°vel automaticamente**, testes s√≥lidos, verifica√ß√µes automatizadas, valida√ß√£o determin√≠stica
- **Seguro para mudan√ßas aut√¥nomas iterativas**, raio de explos√£o limitado, capacidade de revers√£o, entrega progressiva

A mudan√ßa de modelo mental √© significativa. Anteriormente, seu p√∫blico principal era o pr√≥ximo desenvolvedor que leria seu c√≥digo. Agora, seu p√∫blico principal inclui contribuidores n√£o humanos que analisam seu reposit√≥rio para entender como fazer mudan√ßas.

---

## Por Que o Panorama GenAI Parece Avassalador (e Como Responder)

O ecossistema GenAI est√° evoluindo em velocidade sem precedentes: janelas de contexto maiores, agentes que usam ferramentas, sa√≠das estruturadas, fluxos de trabalho com recupera√ß√£o aumentada, assistentes cientes do reposit√≥rio e agentes de codifica√ß√£o totalmente aut√¥nomos. Tentar otimizar para o modelo espec√≠fico de *hoje* √© uma estrat√©gia perdedora.

Em vez disso, otimize para princ√≠pios que sobrevivam √†s mudan√ßas de modelo:

| Princ√≠pio | Por Que Perdura |
|---|---|
| **Inten√ß√£o clara sobre implementa√ß√£o engenhosa** | Cada modelo se beneficia de um enquadramento expl√≠cito do problema |
| **Contratos fortes sobre comportamento impl√≠cito** | Agentes precisam de limites, n√£o de adivinha√ß√£o |
| **Contexto estruturado sobre conhecimento tribal** | O que n√£o est√° documentado √© invis√≠vel para os agentes |
| **Valida√ß√£o determin√≠stica sobre revis√£o manual** | Testes automatizados escalam; aten√ß√£o humana n√£o |

Essas n√£o s√£o apenas pr√°ticas amig√°veis para agentes, s√£o pr√°ticas que tornam seu software melhor para todos. A sobreposi√ß√£o entre "bom para humanos" e "bom para agentes" √© enorme.

---

## Melhores Pr√°ticas para Design de Software Onde os Agentes S√£o Primeiros

### 1. Trate Seu Reposit√≥rio como uma Base de Conhecimento Execut√°vel

Agentes n√£o apenas leem c√≥digo, eles leem o **reposit√≥rio inteiro**. Cada arquivo, cada conven√ß√£o, cada escolha de configura√ß√£o se torna entrada para como um agente raciocina sobre seu sistema.

Seu repo deve responder claramente:

- üèóÔ∏è O que este sistema faz?
- üìÅ Como ele √© estruturado?
- üìç Onde o novo c√≥digo deve ficar?
- ‚úÖ Como validamos as mudan√ßas?
- üö´ Quais padr√µes devem ser evitados?

**Uma estrutura recomendada para repos amig√°veis com agentes:**

```
/.github
  copilot-instructions.md    # Orienta√ß√£o espec√≠fica para agentes
  CODEOWNERS                  # Limites de propriedade
  workflows/                  # Automa√ß√£o CI/CD

/docs
  architecture.md             # Vis√£o geral do design do sistema
  domain-overview.md          # Contexto de neg√≥cio
  coding-standards.md         # Conven√ß√µes e padr√µes
  adr/                        # Registros de Decis√£o de Arquitetura

/specs
  feature-x.spec.md           # Especifica√ß√µes de funcionalidades
  api-contracts.md            # Defini√ß√µes de interfaces

/src                          # C√≥digo da aplica√ß√£o
/tests                        # Su√≠tes de testes
```

A ideia-chave √© direta:

> **Se um novo engenheiro ficaria confuso, um agente tamb√©m ficar√°.**

Mas vai mais fundo. Um novo engenheiro pode fazer perguntas, ler nas entrelinhas e inferir contexto de conversas informais. Um agente n√£o pode. Tudo deve ser expl√≠cito, documentado e descobr√≠vel dentro do pr√≥prio reposit√≥rio.

#### O Poder das Instru√ß√µes do Copilot

Uma das coisas mais impactantes que voc√™ pode fazer hoje √© criar um arquivo `.github/copilot-instructions.md` no seu reposit√≥rio. Este arquivo serve como uma interface direta entre o conhecimento da sua equipe e os agentes de IA. Ele pode incluir:

- Padr√µes arquitet√¥nicos que sua equipe segue
- Conven√ß√µes de nomenclatura e padr√µes de codifica√ß√£o
- Escolhas tecnol√≥gicas e sua justificativa
- Armadilhas comuns a evitar
- Requisitos e estrat√©gias de testes

Isso √© exatamente o que eu fa√ßo no [reposit√≥rio deste site](https://github.com/dsanchezcr/website), o arquivo de instru√ß√µes do copilot cont√©m orienta√ß√£o detalhada sobre a arquitetura do projeto, fluxos de trabalho de desenvolvimento, padr√µes comuns e pontos de integra√ß√£o. Quando o [GitHub Copilot](https://github.com/features/copilot) ou o [agente de codifica√ß√£o do GitHub Copilot](https://github.com/features/copilot) opera neste reposit√≥rio, ele tem acesso imediato ao contexto que de outra forma levaria horas para um novo contribuidor descobrir. √â um exemplo pr√°tico de tratar seu reposit√≥rio como uma base de conhecimento.

---

### 2. Adote o Desenvolvimento Orientado por Especifica√ß√µes

Em um fluxo de trabalho ag√™ntico, as especifica√ß√µes n√£o s√£o opcionais. Elas n√£o s√£o "bom ter." S√£o **essenciais**.

A lacuna entre uma solicita√ß√£o vaga e uma especifica√ß√£o precisa √© onde os agentes falham mais visivelmente. Um agente solicitado a "construir um sistema de autentica√ß√£o de usu√°rios" sem restri√ß√µes produzir√° *algo*, mas provavelmente n√£o corresponder√° ao seu modelo de seguran√ßa, aos seus requisitos de experi√™ncia do usu√°rio ou √†s restri√ß√µes da sua infraestrutura.

Uma especifica√ß√£o s√≥lida (o que alguns chamam de DevSpec) deve incluir:

| Componente | Prop√≥sito | Exemplo |
|---|---|---|
| **Declara√ß√£o do problema** | Por que esta mudan√ßa existe | "Usu√°rios n√£o podem redefinir senhas sem contatar o suporte" |
| **Comportamento esperado** | Como o sucesso se parece | "Usu√°rios recebem um link de redefini√ß√£o com tempo limitado por email" |
| **Restri√ß√µes** | Limites inegoci√°veis | "Tokens expiram ap√≥s 15 minutos, uso √∫nico" |
| **Contratos de API** | Defini√ß√µes de interface | "POST /api/reset-password aceita email, retorna 202" |
| **Casos extremos** | O que pode dar errado | "Emails inv√°lidos, tokens expirados, requisi√ß√µes concorrentes" |
| **Crit√©rios de aceita√ß√£o** | Como verificar a conclus√£o | "Todos os testes passam, revis√£o de seguran√ßa completa" |

Por que isso importa tanto para os agentes?

- Agentes geram melhores solu√ß√µes quando a inten√ß√£o √© expl√≠cita, **lixo entra, lixo sai** se aplica duplamente √† IA
- As revis√µes de PR se tornam valida√ß√£o da especifica√ß√£o em vez de adivinha√ß√£o sobre a inten√ß√£o
- As mudan√ßas permanecem consistentes entre modelos e ferramentas, se voc√™ trocar de uma ferramenta de IA para outra, a especifica√ß√£o continua sendo sua fonte de verdade

Pense nas especifica√ß√µes como:

> **A interface est√°vel entre a inten√ß√£o humana e a execu√ß√£o da m√°quina.**

---

### 3. Fa√ßa dos Testes o Mecanismo Principal de Seguran√ßa

Em um fluxo de trabalho onde os agentes s√£o primeiros, o c√≥digo √© gerado mais r√°pido, os PRs s√£o mais frequentes e as itera√ß√µes acontecem na velocidade da m√°quina. A revis√£o manual sozinha n√£o escala.

Esta √© talvez a pr√°tica mais importante a internalizar:

> **Humanos definem a inten√ß√£o. Agentes implementam. Testes arbitram a verdade.**

As implica√ß√µes s√£o pr√°ticas e imediatas:

- ‚úÖ **Invista em testes automatizados determin√≠sticos**, testes inst√°veis minam a valida√ß√£o de c√≥digo gerado por agentes
- ‚úÖ **Use testes focados em comportamento**, n√£o testes de implementa√ß√£o, agentes podem implementar diferentemente de como voc√™ faria, e tudo bem desde que o comportamento esteja correto
- ‚úÖ **Trate testes como contratos**, n√£o como m√©tricas de cobertura, 80% de cobertura que testa as coisas erradas √© pior que 40% de cobertura que testa os caminhos cr√≠ticos
- ‚úÖ **Fa√ßa testes r√°pidos**, su√≠tes de testes lentas criam fric√ß√£o que encoraja pular a valida√ß√£o

Quando um agente abre um pull request, seu pipeline de CI se torna a primeira linha de defesa. Se seus testes s√£o abrangentes e confi√°veis, voc√™ pode revisar com confian√ßa. Se s√£o escassos ou inst√°veis, cada PR gerado por agente se torna uma fonte de ansiedade.

#### A Pir√¢mide de Testes em um Mundo Onde os Agentes S√£o Primeiros

A pir√¢mide de testes tradicional ainda vale, mas a √™nfase muda:

| N√≠vel | Prioridade Agent-First | Por Qu√™ |
|---|---|---|
| **Testes unit√°rios** | Alta | Feedback r√°pido sobre a corre√ß√£o de componentes individuais |
| **Testes de integra√ß√£o** | Cr√≠tica | Valida que o c√≥digo gerado por agentes funciona com os sistemas existentes |
| **Testes de contrato** | Essencial | Garante que os limites de API n√£o sejam violados |
| **Testes de ponta a ponta** | Importante | Captura comportamento emergente de mudan√ßas combinadas |
| **Testes de seguran√ßa** | Inegoci√°vel | Agentes podem introduzir vulnerabilidades sutis |

---

### 4. Otimize para Descobribilidade, N√£o para Engenhosidade

Este princ√≠pio merece √™nfase especial porque vai contra a forma como muitos desenvolvedores experientes trabalham.

Agentes t√™m dificuldade com:

- üî¥ Depend√™ncias ocultas e conven√ß√µes impl√≠citas
- üî¥ Abstra√ß√µes m√°gicas que obscurecem o comportamento
- üî¥ C√≥digo excessivamente compacto que sacrifica legibilidade por brevidade
- üî¥ Documenta√ß√£o escassa e acr√¥nimos indefinidos
- üî¥ Padr√µes inconsistentes em diferentes partes do c√≥digo

Agentes prosperam com:

- üü¢ Limites expl√≠citos de m√≥dulos e fluxos de depend√™ncia claros
- üü¢ Nomenclatura descritiva que comunica a inten√ß√£o
- üü¢ Componentes autocontidos com interfaces √≥bvias
- üü¢ Padr√µes consistentes aplicados uniformemente
- üü¢ Diagramas de arquitetura e registros de decis√£o

Aqui est√° um teste pr√°tico:

> **Um novo engenheiro poderia entender este m√≥dulo em 15 minutos? Poderia fazer uma mudan√ßa segura em 30?**

Se n√£o, um agente provavelmente tamb√©m n√£o. E diferentemente do novo engenheiro, o agente n√£o far√° perguntas esclarecedoras, ele far√° suposi√ß√µes, e essas suposi√ß√µes podem estar erradas.

#### Exemplo Concreto: Boa vs. M√° Descobribilidade

**M√° descobribilidade:**
```csharp
// O que isso faz? Qual √© o contexto? Quais s√£o os efeitos colaterais?
public async Task<Result> Process(Request r) =>
    await _h.Handle(r, _c.GetConfig(), _v.Validate(r) ? Mode.Full : Mode.Partial);
```

**Boa descobribilidade:**
```csharp
/// <summary>
/// Processa um pedido de cliente atrav√©s de valida√ß√£o, precifica√ß√£o e cumprimento.
/// Retorna um Result indicando sucesso ou falha com detalhes espec√≠ficos do erro.
/// </summary>
public async Task<OrderResult> ProcessCustomerOrder(OrderRequest orderRequest)
{
    var validationResult = _orderValidator.Validate(orderRequest);
    var processingMode = validationResult.IsValid ? ProcessingMode.Full : ProcessingMode.Partial;
    var pricingConfig = _configurationService.GetCurrentPricingConfig();

    return await _orderHandler.HandleOrder(orderRequest, pricingConfig, processingMode);
}
```

A segunda vers√£o √© mais longa, mas um agente (ou um novo desenvolvedor) pode raciocinar sobre ela imediatamente. A inten√ß√£o √© clara, as depend√™ncias s√£o vis√≠veis e o fluxo √© √≥bvio.

---

### 5. Projete Pull Requests para Racioc√≠nio Colaborativo

Na era ag√™ntica, PRs se tornam mais do que diffs de c√≥digo. Eles se tornam **artefatos de racioc√≠nio**, documentos que explicam n√£o apenas *o que* mudou, mas *por que*, *como* e *sob quais restri√ß√µes*.

Um PR s√≥lido gerado por agentes deve incluir:

- üìù **O que mudou**, resumo claro das modifica√ß√µes
- üéØ **Por que mudou**, liga√ß√£o √† issue ou especifica√ß√£o que motivou
- üìã **Qual especifica√ß√£o satisfaz**, rastreabilidade at√© os requisitos
- ‚ö†Ô∏è **Riscos e suposi√ß√µes**, o que pode dar errado, o que foi assumido
- üß™ **Resumo de cobertura de testes**, o que est√° validado e o que n√£o est√°

O objetivo n√£o s√£o PRs menores nem maiores:

> **O objetivo s√£o PRs que se expliquem claramente o suficiente para que humanos decidam rapidamente.**

Quando o [agente de codifica√ß√£o do GitHub Copilot](https://github.com/features/copilot) abre um PR, ele tipicamente inclui uma descri√ß√£o do que fez e por qu√™. Mas o trabalho do revisor humano √© avaliar essa descri√ß√£o contra seu conhecimento do sistema. Quanto mais claro o PR, mais r√°pida e precisa essa avalia√ß√£o se torna.

---

### 6. Prepare Seu Fluxo de Trabalho para a Evolu√ß√£o dos Modelos

Os modelos v√£o mudar, rapidamente. Suas pr√°ticas de engenharia **n√£o devem depender das for√ßas ou limita√ß√µes de um modelo espec√≠fico**.

Aqui est√° em que investir:

| Investimento | Sobrevive √†s Mudan√ßas de Modelo? | Por Qu√™ |
|---|---|---|
| Clareza e estrutura do repo | ‚úÖ Sim | Cada modelo se beneficia de contexto claro |
| Especifica√ß√µes estruturadas | ‚úÖ Sim | A inten√ß√£o √© agn√≥stica ao modelo |
| Valida√ß√£o automatizada | ‚úÖ Sim | Testes n√£o se importam quem escreveu o c√≥digo |
| Contratos e interfaces claras | ‚úÖ Sim | Limites se aplicam independentemente das ferramentas |
| Decis√µes de arquitetura documentadas | ‚úÖ Sim | Contexto ajuda todos os futuros contribuidores |
| Engenharia de prompts para um modelo espec√≠fico | ‚ùå N√£o | O comportamento do modelo muda a cada vers√£o |
| Solu√ß√µes alternativas para limita√ß√µes do modelo | ‚ùå N√£o | As limita√ß√µes s√£o tempor√°rias |

Boa engenharia sobrevive a qualquer gera√ß√£o individual de IA. As equipes que investirem em clareza estrutural hoje se beneficiar√£o seja quando as janelas de contexto crescerem para milh√µes de tokens, agentes se tornarem totalmente aut√¥nomos ou paradigmas de IA inteiramente novos emergirem.

---

## O Verdadeiro Desafio: Mudar Como as Equipes Pensam

As pr√°ticas t√©cnicas acima s√£o importantes, mas a parte mais dif√≠cil do design onde os agentes s√£o primeiros n√£o √© t√©cnica, √© cultural.

### Desafio 1: "Sempre Fizemos Assim"

Muitas equipes t√™m conven√ß√µes impl√≠citas que desenvolvedores experientes "simplesmente sabem." Essas conven√ß√µes s√£o invis√≠veis para os agentes. O desafio √© tornar o impl√≠cito expl√≠cito, e muitas equipes resistem porque a documenta√ß√£o parece sobrecarga.

**O reenquadramento:** Documenta√ß√£o n√£o √© sobrecarga quando seu contribuidor mais produtivo (um agente de IA) literalmente n√£o pode funcionar sem ela. Tempo gasto documentando √© tempo multiplicado em cada intera√ß√£o futura com agentes.

### Desafio 2: Superando a Percep√ß√£o de "N√£o √â Bom o Suficiente"

Alguns desenvolvedores descartam c√≥digo gerado por agentes porque "n√£o √© como eu escreveria." Isso confunde estilo com corre√ß√£o. Agentes podem escolher padr√µes diferentes, nomes de vari√°veis diferentes, abstra√ß√µes diferentes, e tudo bem se o comportamento estiver correto e o c√≥digo for mant√≠vel.

**O reenquadramento:** A pergunta n√£o √© "Eu escreveria assim?" mas "Isso atende nossos padr√µes de corre√ß√£o, seguran√ßa e manutenibilidade?"

### Desafio 3: Equilibrar Velocidade com Seguran√ßa

Os ganhos de velocidade dos agentes de IA s√£o reais e significativos. Mas velocidade sem seguran√ßa cria d√≠vida t√©cnica na velocidade da IA. Equipes que pulam testes, evitam revis√µes ou eliminam port√µes de qualidade em busca de velocidade pagar√£o o pre√ßo exponencialmente.

**O reenquadramento:** O design onde os agentes s√£o primeiros n√£o √© sobre ir mais r√°pido removendo barreiras. √â sobre **ir mais r√°pido porque suas barreiras s√£o automatizadas e confi√°veis**.

### Desafio 4: Manter os Humanos Engajados

Quando os agentes lidam com mais do trabalho rotineiro, h√° um risco de que os engenheiros humanos se desconectem, tratando a sa√≠da da IA como autoritativa e carimbando revis√µes sem pensar. Este √© o modo de falha mais perigoso porque √© invis√≠vel at√© que algo d√™ errado.

**O reenquadramento:** O papel do engenheiro muda de *escrever* c√≥digo para *avaliar* c√≥digo com o mesmo (ou maior) rigor. Habilidades de revis√£o se tornam premium, e engajamento ativo com a sa√≠da da IA √© uma responsabilidade profissional fundamental.

---

## Uma Lista de Verifica√ß√£o Pr√°tica para Reposit√≥rios Prontos para Agentes

Aqui est√° uma autoavalia√ß√£o que voc√™ pode aplicar aos reposit√≥rios da sua equipe hoje:

### Estrutura do Reposit√≥rio

- Organiza√ß√£o clara de diret√≥rios com conven√ß√µes de nomenclatura consistentes
- README com vis√£o geral da arquitetura, instru√ß√µes de configura√ß√£o e guias de contribui√ß√£o
- `.github/copilot-instructions.md` com orienta√ß√£o espec√≠fica do projeto para agentes de IA
- Registros de Decis√£o de Arquitetura (ADRs) para decis√µes t√©cnicas significativas

### Documenta√ß√£o

- Contratos de API e defini√ß√µes de interface documentados e atualizados
- Padr√µes de codifica√ß√£o e padr√µes explicitamente documentados (n√£o apenas conhecimento tribal)
- Conceitos de dom√≠nio e regras de neg√≥cio definidos onde o c√≥digo os implementa

### Testes

- Su√≠te de testes abrangente que executa r√°pida e confiavelmente
- Testes focam em comportamento, n√£o em detalhes de implementa√ß√£o
- Pipeline de CI aplica testes em cada PR, sem exce√ß√µes
- Escaneamento de seguran√ßa est√° automatizado e n√£o pode ser contornado

### Governan√ßa

- Regras de prote√ß√£o de branch s√£o aplicadas nas branches cr√≠ticas
- Arquivo CODEOWNERS define requisitos de revis√£o espec√≠ficos por dom√≠nio
- PRs gerados por agentes recebem o mesmo rigor de revis√£o que PRs humanos
- Procedimentos de revers√£o est√£o documentados e testados

### Colabora√ß√£o

- Especifica√ß√µes s√£o escritas antes do in√≠cio da implementa√ß√£o
- Descri√ß√µes de PR explicam o *por qu√™*, n√£o apenas o *que*
- Labels distinguem contribui√ß√µes geradas por agentes das geradas por humanos
- Feedback de revis√µes melhora as instru√ß√µes do agente (copilot-instructions.md)

---

## A Mudan√ßa de Mentalidade: Engenheiros como Designers de Sistemas

A mudan√ßa mais importante n√£o √© t√©cnica, √© conceitual.

Em um mundo onde os agentes s√£o primeiros, os engenheiros cada vez mais:

- üéØ **Definem a inten√ß√£o**, o que o sistema deve fazer e por qu√™?
- üìê **Projetam restri√ß√µes**, dentro de quais limites os agentes devem operar?
- üèóÔ∏è **Estruturam sistemas**, como o reposit√≥rio, o pipeline e a infraestrutura devem ser organizados?
- üîç **Revisam resultados**, esta mudan√ßa atende nossos padr√µes?
- üìà **Guiam a evolu√ß√£o da arquitetura**, como o sistema deve crescer ao longo do tempo?

Menos tempo √© gasto escrevendo c√≥digo repetitivo, refatora√ß√£o manual, pesquisando documenta√ß√£o e repetindo padr√µes comuns.

Mais tempo √© dedicado a:

> **Projetar sistemas que tanto humanos quanto agentes possam evoluir juntos com seguran√ßa.**

Isso √© o que descrevi em [A Evolu√ß√£o do Engenheiro de Software](/blog/evolution-of-the-software-engineer), a mudan√ßa de autor de c√≥digo para designer de sistemas. O design de software onde os agentes s√£o primeiros √© a express√£o arquitet√¥nica dessa evolu√ß√£o.

---

## Pensamentos Finais

A r√°pida evolu√ß√£o de GenAI e dos LLMs pode parecer avassaladora, mas o caminho a seguir √© surpreendentemente est√°vel.

Voc√™ n√£o precisa perseguir cada novo modelo ou funcionalidade. Em vez disso:

- üèóÔ∏è Estruture reposit√≥rios claramente
- üìã Escreva especifica√ß√µes expl√≠citas
- üß™ Invista em testes automatizados s√≥lidos
- üîç Projete arquiteturas descobr√≠veis
- üìù Trate PRs como artefatos de racioc√≠nio
- ü§ù Otimize para colabora√ß√£o entre humanos e agentes

As equipes que adotarem essas pr√°ticas n√£o apenas acompanhar√£o o ritmo da era ag√™ntica, elas **construir√£o software que est√° pronto para o que vier a seguir**.

Os agentes est√£o aqui. Seu reposit√≥rio √© a interface deles. Projete-o adequadamente.
