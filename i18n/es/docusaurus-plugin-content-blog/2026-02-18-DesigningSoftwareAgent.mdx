---
title: "DiseÃ±ando Software para un Mundo Donde los Agentes Son Primero"
description: La arquitectura, los repositorios y las prÃ¡cticas de ingenierÃ­a deben evolucionar para la era GenAI. Aprende cÃ³mo diseÃ±ar sistemas amigables para agentes que sobrevivan los cambios de modelos, habiliten contribuciones autÃ³nomas seguras y hagan mÃ¡s efectivos tanto a humanos como a mÃ¡quinas.
slug: designing-software-agent-first-world
authors: [dsanchezcr]
tags: [AI, GitHub Copilot, Agentic AI, Software Engineering, Architecture, DevOps]
enableComments: true
hide_table_of_contents: true
image: https://raw.githubusercontent.com/dsanchezcr/website/refs/heads/main/static/img/blog/2026-02-18-DesigningSoftwareAgent/designing-software-agent-first-world.jpg
date: 2026-02-18T10:00
---

# DiseÃ±ando Software para un Mundo Donde los Agentes Son Primero

## Tu Repositorio Es Ahora Tu Interfaz MÃ¡s Importante

El rol del ingeniero de software estÃ¡ evolucionando rÃ¡pidamente, no porque la IA pueda generar cÃ³digo, sino porque el desarrollo de software en sÃ­ se estÃ¡ convirtiendo en un **sistema colaborativo humano-agente**.

En los Ãºltimos aÃ±os, pasamos de la IA asistiendo con fragmentos de cÃ³digo, a generar funciones completas, a proponer pull requests, y ahora a **agentes que navegan repositorios, razonan sobre arquitectura y ejecutan tareas de desarrollo de mÃºltiples pasos de forma autÃ³noma**.

<!--truncate-->

![DiseÃ±ando Software para un Mundo Donde los Agentes Son Primero](pathname:///img/blog/2026-02-18-DesigningSoftwareAgent/designing-software-agent-first-world.jpg)

En mis publicaciones anteriores, explorÃ© cÃ³mo [las prÃ¡cticas fundamentales de DevOps preparan el sistema](/blog/agentic-devops-foundations), cÃ³mo [el rol del ingeniero de software estÃ¡ evolucionando](/blog/evolution-of-the-software-engineer), y cÃ³mo [humanos y agentes colaboran a travÃ©s de IDEs y pull requests](/blog/humans-and-agents-collaboration-patterns). Esta publicaciÃ³n aborda la siguiente pregunta crÃ­tica:

> **Â¿CÃ³mo deberÃ­amos diseÃ±ar nuestros sistemas de software para que los agentes puedan trabajar en ellos de manera efectiva, segura y a escala?**

El ritmo de innovaciÃ³n en GenAI y LLMs puede sentirse abrumador. Nuevos modelos, capacidades, frameworks y mejores prÃ¡cticas aparecen constantemente. Muchos desarrolladores se preguntan: *Â¿QuÃ© modelos deberÃ­a usar? Â¿CÃ³mo estructuro mi repo para que los agentes lo entiendan? Â¿QuÃ© significa "mejor prÃ¡ctica" cuando las herramientas evolucionan cada mes?*

La respuesta no es perseguir cada nuevo modelo o funcionalidad.

La respuesta es **diseÃ±ar sistemas de software que sean amigables para agentes por defecto**.

---

## De la CodificaciÃ³n Asistida por IA a la IngenierÃ­a Donde los Agentes Son Primero

El diseÃ±o de software tradicional asumÃ­a que los humanos escriben cÃ³digo, los humanos leen la documentaciÃ³n de arquitectura, los humanos entienden la intenciÃ³n y los humanos coordinan los cambios. Esas suposiciones ya no se sostienen.

La ingenierÃ­a agÃ©ntica introduce una nueva realidad:

> **Tu software serÃ¡ leÃ­do, modificado, probado y analizado tanto por mÃ¡quinas como por humanos.**

Esto cambia lo que significa "buena ingenierÃ­a". El buen diseÃ±o ya no es solo legible para humanos y mantenible por equipos. TambiÃ©n debe ser:

- **Navegable por agentes**, estructura clara, convenciones explÃ­citas, patrones descubribles
- **Verificable automÃ¡ticamente**, pruebas sÃ³lidas, verificaciones automatizadas, validaciÃ³n determinista
- **Seguro para cambios autÃ³nomos iterativos**, radio de explosiÃ³n acotado, capacidad de reversiÃ³n, entrega progresiva

El cambio de modelo mental es significativo. Antes, tu audiencia principal era el siguiente desarrollador que leerÃ­a tu cÃ³digo. Ahora, tu audiencia principal incluye contribuyentes no humanos que analizan tu repositorio para entender cÃ³mo hacer cambios.

---

## Por QuÃ© el Panorama GenAI Se Siente Abrumador (y CÃ³mo Responder)

El ecosistema GenAI estÃ¡ evolucionando a una velocidad sin precedentes: ventanas de contexto mÃ¡s grandes, agentes que usan herramientas, salidas estructuradas, flujos de trabajo con recuperaciÃ³n aumentada, asistentes conscientes del repositorio y agentes de codificaciÃ³n completamente autÃ³nomos. Intentar optimizar para el modelo especÃ­fico de *hoy* es una estrategia perdedora.

En su lugar, optimiza para principios que sobrevivan los cambios de modelo:

| Principio | Por QuÃ© Perdura |
|---|---|
| **IntenciÃ³n clara sobre implementaciÃ³n ingeniosa** | Cada modelo se beneficia de un planteamiento explÃ­cito del problema |
| **Contratos fuertes sobre comportamiento implÃ­cito** | Los agentes necesitan lÃ­mites, no adivinanzas |
| **Contexto estructurado sobre conocimiento tribal** | Lo que no estÃ¡ documentado es invisible para los agentes |
| **ValidaciÃ³n determinista sobre revisiÃ³n manual** | Las pruebas automatizadas escalan; la atenciÃ³n humana no |

Estas no son solo prÃ¡cticas amigables para agentes, son prÃ¡cticas que mejoran tu software para todos. La superposiciÃ³n entre "bueno para humanos" y "bueno para agentes" es enorme.

---

## Mejores PrÃ¡cticas para el DiseÃ±o de Software Donde los Agentes Son Primero

### 1. Trata Tu Repositorio como una Base de Conocimiento Ejecutable

Los agentes no solo leen cÃ³digo, leen el **repositorio completo**. Cada archivo, cada convenciÃ³n, cada decisiÃ³n de configuraciÃ³n se convierte en entrada para cÃ³mo un agente razona sobre tu sistema.

Tu repo deberÃ­a responder claramente:

- ğŸ—ï¸ Â¿QuÃ© hace este sistema?
- ğŸ“ Â¿CÃ³mo estÃ¡ estructurado?
- ğŸ“ Â¿DÃ³nde deberÃ­a vivir el cÃ³digo nuevo?
- âœ… Â¿CÃ³mo validamos los cambios?
- ğŸš« Â¿QuÃ© patrones deben evitarse?

**Una estructura recomendada para repos amigables con agentes:**

```
/.github
  copilot-instructions.md    # GuÃ­a especÃ­fica para agentes
  CODEOWNERS                  # LÃ­mites de propiedad
  workflows/                  # AutomatizaciÃ³n CI/CD

/docs
  architecture.md             # VisiÃ³n general del diseÃ±o del sistema
  domain-overview.md          # Contexto de negocio
  coding-standards.md         # Convenciones y patrones
  adr/                        # Registros de Decisiones de Arquitectura

/specs
  feature-x.spec.md           # Especificaciones de funcionalidades
  api-contracts.md            # Definiciones de interfaces

/src                          # CÃ³digo de la aplicaciÃ³n
/tests                        # Suites de pruebas
```

La idea clave es directa:

> **Si un nuevo ingeniero estarÃ­a confundido, un agente tambiÃ©n lo estarÃ¡.**

Pero va mÃ¡s allÃ¡. Un nuevo ingeniero puede hacer preguntas, leer entre lÃ­neas e inferir contexto de conversaciones informales. Un agente no puede. Todo debe ser explÃ­cito, documentado y descubrible dentro del repositorio mismo.

#### El Poder de las Instrucciones de Copilot

Una de las cosas mÃ¡s impactantes que puedes hacer hoy es crear un archivo `.github/copilot-instructions.md` en tu repositorio. Este archivo sirve como una interfaz directa entre el conocimiento de tu equipo y los agentes de IA. Puede incluir:

- Patrones arquitectÃ³nicos que sigue tu equipo
- Convenciones de nomenclatura y estÃ¡ndares de codificaciÃ³n
- Elecciones tecnolÃ³gicas y su justificaciÃ³n
- Errores comunes a evitar
- Requisitos y estrategias de pruebas

Esto es exactamente lo que hago en [el repositorio de este sitio web](https://github.com/dsanchezcr/website), el archivo de instrucciones de copilot contiene orientaciÃ³n detallada sobre la arquitectura del proyecto, flujos de trabajo de desarrollo, patrones comunes y puntos de integraciÃ³n. Cuando [GitHub Copilot](https://github.com/features/copilot) o el [agente de codificaciÃ³n de GitHub Copilot](https://github.com/features/copilot) opera en este repositorio, tiene acceso inmediato al contexto que de otro modo tomarÃ­a horas a un nuevo contribuyente descubrir. Es un ejemplo prÃ¡ctico de tratar tu repositorio como una base de conocimiento.

---

### 2. Adopta el Desarrollo Basado en Especificaciones

En un flujo de trabajo agÃ©ntico, las especificaciones no son opcionales. No son "agradables de tener." Son **esenciales**.

La brecha entre una solicitud vaga y una especificaciÃ³n precisa es donde los agentes fallan mÃ¡s visiblemente. Un agente al que se le pide "construir un sistema de autenticaciÃ³n de usuarios" sin restricciones producirÃ¡ *algo*, pero probablemente no coincidirÃ¡ con tu modelo de seguridad, tus requisitos de experiencia de usuario o las restricciones de tu infraestructura.

Una especificaciÃ³n sÃ³lida (lo que algunos llaman DevSpec) deberÃ­a incluir:

| Componente | PropÃ³sito | Ejemplo |
|---|---|---|
| **Planteamiento del problema** | Por quÃ© existe este cambio | "Los usuarios no pueden restablecer sus contraseÃ±as sin contactar soporte" |
| **Comportamiento esperado** | CÃ³mo se ve el Ã©xito | "Los usuarios reciben un enlace de restablecimiento con tiempo limitado por correo" |
| **Restricciones** | LÃ­mites no negociables | "Los tokens expiran despuÃ©s de 15 minutos, un solo uso" |
| **Contratos de API** | Definiciones de interfaz | "POST /api/reset-password acepta email, retorna 202" |
| **Casos extremos** | QuÃ© podrÃ­a salir mal | "Emails invÃ¡lidos, tokens expirados, solicitudes concurrentes" |
| **Criterios de aceptaciÃ³n** | CÃ³mo verificar la completitud | "Todas las pruebas pasan, revisiÃ³n de seguridad completa" |

Â¿Por quÃ© importa tanto esto para los agentes?

- Los agentes generan mejores soluciones cuando la intenciÃ³n es explÃ­cita, **basura entra, basura sale** se aplica doblemente a la IA
- Las revisiones de PR se convierten en validaciÃ³n de la especificaciÃ³n en lugar de adivinanzas sobre la intenciÃ³n
- Los cambios permanecen consistentes entre modelos y herramientas, si cambias de una herramienta de IA a otra, la especificaciÃ³n sigue siendo tu fuente de verdad

Piensa en las especificaciones como:

> **La interfaz estable entre la intenciÃ³n humana y la ejecuciÃ³n de la mÃ¡quina.**

---

### 3. Haz de las Pruebas el Mecanismo Principal de Seguridad

En un flujo de trabajo donde los agentes son primero, el cÃ³digo se genera mÃ¡s rÃ¡pido, los PRs son mÃ¡s frecuentes y las iteraciones ocurren a velocidad de mÃ¡quina. La revisiÃ³n manual por sÃ­ sola no escala.

Esta es quizÃ¡s la prÃ¡ctica mÃ¡s importante de internalizar:

> **Los humanos definen la intenciÃ³n. Los agentes implementan. Las pruebas arbitran la verdad.**

Las implicaciones son prÃ¡cticas e inmediatas:

- âœ… **Invierte en pruebas automatizadas deterministas**, las pruebas inestables socavan la validaciÃ³n de cÃ³digo generado por agentes
- âœ… **Usa pruebas enfocadas en comportamiento**, no pruebas de implementaciÃ³n, los agentes pueden implementar de manera diferente a como tÃº lo harÃ­as, y eso estÃ¡ bien siempre que el comportamiento sea correcto
- âœ… **Trata las pruebas como contratos**, no como mÃ©tricas de cobertura, 80% de cobertura que prueba las cosas equivocadas es peor que 40% de cobertura que prueba las rutas crÃ­ticas
- âœ… **Haz que las pruebas sean rÃ¡pidas**, las suites de pruebas lentas crean fricciÃ³n que incentiva saltarse la validaciÃ³n

Cuando un agente abre un pull request, tu pipeline de CI se convierte en la primera lÃ­nea de defensa. Si tus pruebas son completas y confiables, puedes revisar con confianza. Si son escasas o inestables, cada PR generado por agente se convierte en una fuente de ansiedad.

#### La PirÃ¡mide de Pruebas en un Mundo Donde los Agentes Son Primero

La pirÃ¡mide de pruebas tradicional sigue vigente, pero el Ã©nfasis cambia:

| Nivel | Prioridad Agent-First | Por QuÃ© |
|---|---|---|
| **Pruebas unitarias** | Alta | RetroalimentaciÃ³n rÃ¡pida sobre la correcciÃ³n de componentes individuales |
| **Pruebas de integraciÃ³n** | CrÃ­tica | Valida que el cÃ³digo generado por agentes funciona con los sistemas existentes |
| **Pruebas de contrato** | Esencial | Asegura que los lÃ­mites de API no se violen |
| **Pruebas de extremo a extremo** | Importante | Detecta comportamiento emergente de cambios combinados |
| **Pruebas de seguridad** | No negociable | Los agentes pueden introducir vulnerabilidades sutiles |

---

### 4. Optimiza para la Descubribilidad, No para la Ingeniosidad

Este principio merece Ã©nfasis especial porque va en contra de cÃ³mo trabajan muchos desarrolladores experimentados.

Los agentes tienen dificultades con:

- ğŸ”´ Dependencias ocultas y convenciones implÃ­citas
- ğŸ”´ Abstracciones mÃ¡gicas que oscurecen el comportamiento
- ğŸ”´ CÃ³digo excesivamente compacto que sacrifica legibilidad por brevedad
- ğŸ”´ DocumentaciÃ³n escasa y acrÃ³nimos indefinidos
- ğŸ”´ Patrones inconsistentes en diferentes partes del cÃ³digo

Los agentes prosperan con:

- ğŸŸ¢ LÃ­mites explÃ­citos de mÃ³dulos y flujos de dependencia claros
- ğŸŸ¢ Nomenclatura descriptiva que comunica la intenciÃ³n
- ğŸŸ¢ Componentes autocontenidos con interfaces obvias
- ğŸŸ¢ Patrones consistentes aplicados uniformemente
- ğŸŸ¢ Diagramas de arquitectura y registros de decisiones

AquÃ­ hay una prueba prÃ¡ctica:

> **Â¿PodrÃ­a un nuevo ingeniero entender este mÃ³dulo en 15 minutos? Â¿PodrÃ­a hacer un cambio seguro en 30?**

Si no, un agente probablemente tampoco. Y a diferencia del nuevo ingeniero, el agente no harÃ¡ preguntas aclaratorias, harÃ¡ suposiciones, y esas suposiciones pueden ser incorrectas.

#### Ejemplo Concreto: Buena vs. Mala Descubribilidad

**Mala descubribilidad:**
```csharp
// Â¿QuÃ© hace esto? Â¿CuÃ¡l es el contexto? Â¿CuÃ¡les son los efectos secundarios?
public async Task<Result> Process(Request r) =>
    await _h.Handle(r, _c.GetConfig(), _v.Validate(r) ? Mode.Full : Mode.Partial);
```

**Buena descubribilidad:**
```csharp
/// <summary>
/// Procesa un pedido de cliente a travÃ©s de validaciÃ³n, fijaciÃ³n de precios y cumplimiento.
/// Retorna un Result indicando Ã©xito o fallo con detalles especÃ­ficos del error.
/// </summary>
public async Task<OrderResult> ProcessCustomerOrder(OrderRequest orderRequest)
{
    var validationResult = _orderValidator.Validate(orderRequest);
    var processingMode = validationResult.IsValid ? ProcessingMode.Full : ProcessingMode.Partial;
    var pricingConfig = _configurationService.GetCurrentPricingConfig();

    return await _orderHandler.HandleOrder(orderRequest, pricingConfig, processingMode);
}
```

La segunda versiÃ³n es mÃ¡s larga, pero un agente (o un nuevo desarrollador) puede razonar sobre ella inmediatamente. La intenciÃ³n es clara, las dependencias son visibles y el flujo es obvio.

---

### 5. DiseÃ±a Pull Requests para el Razonamiento Colaborativo

En la era agÃ©ntica, los PRs se convierten en mÃ¡s que diffs de cÃ³digo. Se convierten en **artefactos de razonamiento**, documentos que explican no solo *quÃ©* cambiÃ³, sino *por quÃ©*, *cÃ³mo* y *bajo quÃ© restricciones*.

Un PR sÃ³lido generado por agentes deberÃ­a incluir:

- ğŸ“ **QuÃ© cambiÃ³**, resumen claro de las modificaciones
- ğŸ¯ **Por quÃ© cambiÃ³**, vinculaciÃ³n al issue o especificaciÃ³n que lo motivÃ³
- ğŸ“‹ **QuÃ© especificaciÃ³n satisface**, trazabilidad hacia los requisitos
- âš ï¸ **Riesgos y suposiciones**, quÃ© podrÃ­a salir mal, quÃ© se asumiÃ³
- ğŸ§ª **Resumen de cobertura de pruebas**, quÃ© estÃ¡ validado y quÃ© no

El objetivo no son PRs mÃ¡s pequeÃ±os ni mÃ¡s grandes:

> **El objetivo son PRs que se expliquen lo suficientemente claro para que los humanos decidan rÃ¡pidamente.**

Cuando el [agente de codificaciÃ³n de GitHub Copilot](https://github.com/features/copilot) abre un PR, tÃ­picamente incluye una descripciÃ³n de quÃ© hizo y por quÃ©. Pero el trabajo del revisor humano es evaluar esa descripciÃ³n contra su conocimiento del sistema. Cuanto mÃ¡s claro sea el PR, mÃ¡s rÃ¡pida y precisa serÃ¡ esa evaluaciÃ³n.

---

### 6. Prepara Tu Flujo de Trabajo para la EvoluciÃ³n de los Modelos

Los modelos cambiarÃ¡n, rÃ¡pidamente. Tus prÃ¡cticas de ingenierÃ­a **no deberÃ­an depender de las fortalezas o limitaciones de un modelo especÃ­fico**.

AquÃ­ estÃ¡ en quÃ© invertir:

| InversiÃ³n | Â¿Sobrevive a los Cambios de Modelo? | Por QuÃ© |
|---|---|---|
| Claridad y estructura del repo | âœ… SÃ­ | Cada modelo se beneficia de contexto claro |
| Especificaciones estructuradas | âœ… SÃ­ | La intenciÃ³n es agnÃ³stica al modelo |
| ValidaciÃ³n automatizada | âœ… SÃ­ | Las pruebas no se importan quiÃ©n escribiÃ³ el cÃ³digo |
| Contratos e interfaces claras | âœ… SÃ­ | Los lÃ­mites aplican sin importar las herramientas |
| Decisiones de arquitectura documentadas | âœ… SÃ­ | El contexto ayuda a todos los futuros contribuyentes |
| IngenierÃ­a de prompts para un modelo especÃ­fico | âŒ No | El comportamiento del modelo cambia con cada versiÃ³n |
| Soluciones alternativas para limitaciones del modelo | âŒ No | Las limitaciones son temporales |

La buena ingenierÃ­a sobrevive a cualquier generaciÃ³n individual de IA. Los equipos que inviertan en claridad estructural hoy se beneficiarÃ¡n ya sea que las ventanas de contexto crezcan a millones de tokens, los agentes se vuelvan completamente autÃ³nomos o emerjan paradigmas de IA completamente nuevos.

---

## El Verdadero DesafÃ­o: Cambiar CÃ³mo Piensan los Equipos

Las prÃ¡cticas tÃ©cnicas anteriores son importantes, pero la parte mÃ¡s difÃ­cil del diseÃ±o donde los agentes son primero no es tÃ©cnica, es cultural.

### DesafÃ­o 1: "Siempre Lo Hemos Hecho AsÃ­"

Muchos equipos tienen convenciones implÃ­citas que los desarrolladores experimentados "simplemente saben." Estas convenciones son invisibles para los agentes. El desafÃ­o es hacer lo implÃ­cito explÃ­cito, y muchos equipos se resisten porque la documentaciÃ³n se siente como sobrecarga.

**El replanteamiento:** La documentaciÃ³n no es sobrecarga cuando tu contribuyente mÃ¡s productivo (un agente de IA) literalmente no puede funcionar sin ella. El tiempo invertido en documentar se multiplica a lo largo de cada interacciÃ³n futura con agentes.

### DesafÃ­o 2: Superar la PercepciÃ³n de "No Es Suficientemente Bueno"

Algunos desarrolladores desestiman el cÃ³digo generado por agentes porque "no es como yo lo escribirÃ­a." Esto confunde estilo con correcciÃ³n. Los agentes pueden elegir diferentes patrones, diferentes nombres de variables, diferentes abstracciones, y eso estÃ¡ bien si el comportamiento es correcto y el cÃ³digo es mantenible.

**El replanteamiento:** La pregunta no es "Â¿Lo escribirÃ­a yo asÃ­?" sino "Â¿Cumple con nuestros estÃ¡ndares de correcciÃ³n, seguridad y mantenibilidad?"

### DesafÃ­o 3: Equilibrar Velocidad con Seguridad

Las ganancias de velocidad de los agentes de IA son reales y significativas. Pero la velocidad sin seguridad crea deuda tÃ©cnica a velocidad de IA. Los equipos que omiten pruebas, evitan revisiones o eliminan puertas de calidad en busca de velocidad pagarÃ¡n el precio exponencialmente.

**El replanteamiento:** El diseÃ±o donde los agentes son primero no se trata de ir mÃ¡s rÃ¡pido eliminando barreras. Se trata de **ir mÃ¡s rÃ¡pido porque tus barreras estÃ¡n automatizadas y son confiables**.

### DesafÃ­o 4: Mantener a los Humanos Comprometidos

Cuando los agentes manejan mÃ¡s del trabajo rutinario, hay un riesgo de que los ingenieros humanos se desconecten, tratando la salida de la IA como autoritativa y aprobando revisiones sin pensar. Este es el modo de fallo mÃ¡s peligroso porque es invisible hasta que algo sale mal.

**El replanteamiento:** El rol del ingeniero cambia de *escribir* cÃ³digo a *evaluar* cÃ³digo con el mismo (o mayor) rigor. Las habilidades de revisiÃ³n se vuelven premium, y el compromiso activo con la salida de IA es una responsabilidad profesional fundamental.

---

## Una Lista de VerificaciÃ³n PrÃ¡ctica para Repositorios Listos para Agentes

AquÃ­ hay una autoevaluaciÃ³n que puedes aplicar a los repositorios de tu equipo hoy:

### Estructura del Repositorio
- [ ] OrganizaciÃ³n clara de directorios con convenciones de nomenclatura consistentes
- [ ] README con visiÃ³n general de arquitectura, instrucciones de configuraciÃ³n y guÃ­as de contribuciÃ³n
- [ ] `.github/copilot-instructions.md` con orientaciÃ³n especÃ­fica del proyecto para agentes de IA
- [ ] Registros de Decisiones de Arquitectura (ADRs) para decisiones tÃ©cnicas significativas

### DocumentaciÃ³n

- Contratos de API y definiciones de interfaz documentados y actualizados
- EstÃ¡ndares de codificaciÃ³n y patrones explÃ­citamente documentados (no solo conocimiento tribal)
- Conceptos de dominio y reglas de negocio definidos donde el cÃ³digo los implementa

### Pruebas

- Suite de pruebas completa que se ejecuta rÃ¡pida y confiablemente
- Las pruebas se enfocan en comportamiento, no en detalles de implementaciÃ³n
- El pipeline de CI aplica pruebas en cada PR, sin excepciones
- El escaneo de seguridad estÃ¡ automatizado y no se puede eludir

### Gobernanza

- Las reglas de protecciÃ³n de ramas se aplican en las ramas crÃ­ticas
- El archivo CODEOWNERS define requisitos de revisiÃ³n especÃ­ficos por dominio
- Los PRs generados por agentes reciben el mismo rigor de revisiÃ³n que los PRs humanos
- Los procedimientos de reversiÃ³n estÃ¡n documentados y probados

### ColaboraciÃ³n

- Las especificaciones se escriben antes de que comience la implementaciÃ³n
- Las descripciones de PR explican el *por quÃ©*, no solo el *quÃ©*
- Las etiquetas distinguen contribuciones generadas por agentes de las generadas por humanos
- La retroalimentaciÃ³n de revisiones mejora las instrucciones del agente (copilot-instructions.md)

---

## El Cambio de Mentalidad: Ingenieros como DiseÃ±adores de Sistemas

El cambio mÃ¡s importante no es tÃ©cnico, es conceptual.

En un mundo donde los agentes son primero, los ingenieros cada vez mÃ¡s:

- ğŸ¯ **Definen la intenciÃ³n**, Â¿quÃ© deberÃ­a hacer el sistema y por quÃ©?
- ğŸ“ **DiseÃ±an restricciones**, Â¿dentro de quÃ© lÃ­mites deberÃ­an operar los agentes?
- ğŸ—ï¸ **Estructuran sistemas**, Â¿cÃ³mo deberÃ­an organizarse el repositorio, el pipeline y la infraestructura?
- ğŸ” **Revisan resultados**, Â¿este cambio cumple con nuestros estÃ¡ndares?
- ğŸ“ˆ **GuÃ­an la evoluciÃ³n de la arquitectura**, Â¿cÃ³mo deberÃ­a crecer el sistema con el tiempo?

Se dedica menos tiempo a escribir cÃ³digo repetitivo, refactorizaciÃ³n manual, buscar documentaciÃ³n y repetir patrones estÃ¡ndar.

Se dedica mÃ¡s tiempo a:

> **DiseÃ±ar sistemas que tanto humanos como agentes puedan evolucionar juntos de forma segura.**

Esto es lo que describÃ­ en [La EvoluciÃ³n del Ingeniero de Software](/blog/evolution-of-the-software-engineer), el cambio de autor de cÃ³digo a diseÃ±ador de sistemas. El diseÃ±o de software donde los agentes son primero es la expresiÃ³n arquitectÃ³nica de esa evoluciÃ³n.

---

## Pensamientos Finales

La rÃ¡pida evoluciÃ³n de GenAI y los LLMs puede sentirse abrumadora, pero el camino a seguir es sorprendentemente estable.

No necesitas perseguir cada nuevo modelo o funcionalidad. En su lugar:

- ğŸ—ï¸ Estructura los repositorios claramente
- ğŸ“‹ Escribe especificaciones explÃ­citas
- ğŸ§ª Invierte en pruebas automatizadas sÃ³lidas
- ğŸ” DiseÃ±a arquitecturas descubribles
- ğŸ“ Trata los PRs como artefactos de razonamiento
- ğŸ¤ Optimiza para la colaboraciÃ³n entre humanos y agentes

Los equipos que adopten estas prÃ¡cticas no solo mantendrÃ¡n el ritmo de la era agÃ©ntica, **construirÃ¡n software que estÃ© listo para lo que venga despuÃ©s**.

Los agentes estÃ¡n aquÃ­. Tu repositorio es su interfaz. DisÃ©Ã±alo en consecuencia.
